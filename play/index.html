<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline Audio Tagger (Low-Blue-Light Dark)</title>
    <style>
        :root {
            /* Tell the browser to use its native dark controls (dropdowns, audio player).
              This is key for a consistent, non-generic feel.
            */
            color-scheme: dark;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: grid;
            grid-template-areas:
                "header"
                "player"
                "clips"
                "io";
            grid-template-rows: auto auto 1fr auto;
            gap: 15px;
            padding: 15px;
            /* 1. No Pure Black: Better for IPS glow & less harsh. */
            background-color: #1a1a1a; 
            /* 2. No Pure White: Reduces "halation" / text blooming. */
            color: #e0e0e0; 
            height: 95vh;
        }

        header { grid-area: header; }
        #player-controls { grid-area: player; }
        #clips-section { grid-area: clips; display: flex; flex-direction: column; min-height: 200px; }
        #io-section { grid-area: io; }

        h1, h2 {
            margin: 0 0 10px 0;
            border-bottom: 2px solid #444; /* Darker, subtle border */
            padding-bottom: 5px;
            color: #f5f5f5; /* Brighter white for headers */
        }

        /* 3. Depth Hierarchy: Lighter surfaces "come forward" in dark mode. */
        #player-controls,
        #clips-section,
        #io-section > div {
            background: #252525;
            padding: 15px;
            border-radius: 8px;
            /* Subtle edge highlight for better separation */
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.05); 
        }

        #chapter-select {
            font-size: 1.2em;
            padding: 5px;
            margin-right: 10px;
            background-color: #333;
            color: #e0e0e0;
            border: 1px solid #555;
            border-radius: 5px;
        }

        #tag-status {
            padding: 10px 15px;
            font-size: 1.1em;
            font-weight: bold;
            border-radius: 5px;
            color: #fff;
            display: inline-block;
            width: 300px;
            text-align: center;
            transition: background-color 0.3s ease;
        }

        #time-display {
            font-family: "Courier New", Courier, monospace;
            font-size: 1.5em;
            font-weight: bold;
            /* 4. Calibrated Blue: 
              A clear, legible blue for high-visibility info.
              We don't need to make it "yellow" because the
              T√úV screen is already filtering harmful blue light.
            */
            color: #6cb6ff; 
            margin-left: 20px;
        }

        audio {
            width: 100%;
            margin-top: 10px;
        }

        #clips-section {
            overflow-y: auto;
        }

        #clips-list {
            list-style: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
            flex-grow: 1;
        }
        #clips-list li {
            font-family: "Courier New", Courier, monospace;
            padding: 8px;
            border-bottom: 1px solid #444; /* Was #eee */
        }
        /* Subtle zebra striping for readability */
        #clips-list li:nth-child(odd) { 
            background-color: #303030; 
        }

        /* Styling for buttons inside the list */
        #clips-list li button {
            margin-left: 15px; 
            cursor: pointer;
            background-color: #444;
            color: #e0e0e0;
            border: 1px solid #555;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 0.9em;
        }
        #clips-list li button:hover {
             background-color: #555;
        }
        
        /* New class for the delete button (see JS change) */
        .delete-btn {
            color: #ff6b6b; /* Brighter red for dark bg */
            background-color: #4f2a2a;
            border-color: #803030;
        }
        .delete-btn:hover {
            color: #fff;
            background-color: #6a3a3a;
            border-color: #a04040;
        }


        #io-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        #io-section > div {
            display: flex;
            flex-direction: column;
        }
        #io-section textarea {
            width: 100%;
            height: 150px;
            font-family: "Courier New", Courier, monospace;
            box-sizing: border-box; 
            background-color: #1f1f1f;
            color: #d5d5d5;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 8px;
        }
        #io-section textarea:focus {
            border-color: #4a85d4; /* Match button hover */
            outline: none;
        }

        #import-button {
            background-color: #3a75c4; /* Desaturated, clear action blue */
            color: white;
            border: none;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 5px;
            font-weight: bold;
        }
        #import-button:hover { 
            background-color: #4a85d4; 
        }

        /* Dim secondary/hint text */
        #player-controls > div:last-of-type {
            margin-top: 15px;
            font-size: 0.9em;
            color: #aaa; 
        }
    </style>
</head>
<body>

    <header>
        <h1>üéß Offline Audio Tagger</h1>
    </header>

    <section id="player-controls">
        <label for="chapter-select">Chapter:</label>
        <select id="chapter-select"></select>

        <span id="tag-status"></span>
        <span id="time-display">00:00:00.000</span>
        
        <audio id="audio-player" controls></audio>
        
        <div>
            <strong>Shortcuts:</strong> 
            [Space]: Play/Pause |
            [‚Üê]: Rewind 1s |
            [‚Üí]: Forward 1s |
            [1]: Mark Arabic End |
            [2]: Mark Spanish End
        </div>
    </section>

    <section id="clips-section">
        <h2>Marked Clips for <span id="current-chapter-title">...</span></h2>
        <ul id="clips-list">
            </ul>
    </section>

    <section id="io-section">
        <div>
            <h2>Import JSON</h2>
            <textarea id="import-json" placeholder="Paste your timestamps.json content here..."></textarea>
            <button id="import-button">Import and Overwrite</button>
        </div>
        <div>
            <h2>Live JSON Export</h2>
            <textarea id="export-json" readonly placeholder="Your timestamp JSON will appear here..."></textarea>
        </div>
    </section>

    <script>
        // --- GLOBALS ---
        const audioPlayer = document.getElementById('audio-player');
        const chapterSelect = document.getElementById('chapter-select');
        const tagStatus = document.getElementById('tag-status');
        const timeDisplay = document.getElementById('time-display');
        const clipsList = document.getElementById('clips-list');
        const currentChapterTitle = document.getElementById('current-chapter-title');
        const importJsonText = document.getElementById('import-json');
        const exportJsonText = document.getElementById('export-json');
        const importButton = document.getElementById('import-button');

        let db = {}; // Master database for all timestamps
        let playerState = { currentFile: null, currentTime: 0 }; // Last known state
        let taggingState = 'orange'; // 'orange' (waiting for 1) or 'green' (waiting for 2)
        let currentStartTime = null;

        // --- CORE FUNCTIONS ---

        /**
         * Formats seconds into HH:MM:SS.mmm format
         * @param {number} seconds - The time in seconds
         * @returns {string} Formatted time string
         */
        function formatTime(seconds) {
            const ms = Math.floor((seconds % 1) * 1000);
            const totalSec = Math.floor(seconds);
            const h = Math.floor(totalSec / 3600);
            const m = Math.floor((totalSec % 3600) / 60);
            const s = totalSec % 60;
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(3, '0')}`;
        }

        /**
         * Saves the entire timestamp database to localStorage and updates the export box
         */
        function saveDB() {
            try {
                const jsonString = JSON.stringify(db, null, 2);
                localStorage.setItem('timestampDB', jsonString);
                exportJsonText.value = jsonString;
            } catch (e) {
                console.error("Failed to save DB:", e);
                alert("Error saving database. Your data might be too large for localStorage.");
            }
        }

        /**
         * Loads the timestamp database from localStorage
         */
        function loadDB() {
            const storedDB = localStorage.getItem('timestampDB');
            if (storedDB) {
                try {
                    db = JSON.parse(storedDB);
                    exportJsonText.value = JSON.stringify(db, null, 2);
                } catch (e) {
                    console.error("Failed to parse stored DB:", e);
                    db = {};
                }
            } else {
                db = {};
            }
        }

        /**
         * Saves the current player state (file and time) to localStorage
         */
        function savePlayerState() {
            localStorage.setItem('playerState', JSON.stringify(playerState));
        }

        /**
         * Loads the last player state from localStorage
         */
        function loadPlayerState() {
            const storedState = localStorage.getItem('playerState');
            if (storedState) {
                try {
                    playerState = JSON.parse(storedState);
                } catch (e) {
                    console.error("Failed to parse player state:", e);
                    playerState = { currentFile: null, currentTime: 0 };
                }
            }
        }

        /**
         * Populates the chapter select dropdown (1-114)
         */
        function populateChapterSelect() {
            for (let i = 1; i <= 114; i++) {
                const chapterNum = i.toString().padStart(3, '0');
                const option = document.createElement('option');
                option.value = chapterNum;
                option.text = `Chapter ${chapterNum}`;
                chapterSelect.appendChild(option);
            }
        }

        /**
         * Loads a new chapter into the audio player
         * @param {string} chapterNum - The 3-digit chapter number (e.g., "001")
         */
        function loadChapter(chapterNum) {
            const fileName = `coran_${chapterNum}.mp3`;
            const filePath = `Q_espanol/${fileName}`;
            
            audioPlayer.src = filePath;
            playerState.currentFile = fileName;
            playerState.currentTime = 0; // Reset on new chapter load
            savePlayerState();
            
            currentChapterTitle.textContent = `coran_${chapterNum}`;
            renderCurrentChapterClips();
            updateTagStatusUI('orange'); // Reset tag state
        }

        /**
         * Renders the list of marked clips for the currently loaded chapter
         */
        function renderCurrentChapterClips() {
            clipsList.innerHTML = ''; // Clear existing list
            if (!playerState.currentFile) return;

            const chapterKey = playerState.currentFile.split('.')[0]; // e.g., "coran_001"
            const clips = db[chapterKey] || [];

            if (clips.length === 0) {
                clipsList.innerHTML = '<li>No clips marked for this chapter yet.</li>';
            } else {
                clips.forEach(clip => {
                    const li = document.createElement('li');
                    li.textContent = `Verse ${clip.verse}: ${clip.start}  ‚Üí  ${clip.end}`;
                    
                    // Add a jump-to button
                    const jumpBtn = document.createElement('button');
                    jumpBtn.textContent = 'Jump to Start';
                    jumpBtn.onclick = () => {
                        audioPlayer.currentTime = timeStringToSeconds(clip.start);
                        audioPlayer.play();
                    };
                    li.appendChild(jumpBtn);

                    // Add a delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'Delete';
                    // *** MODIFICATION: Use class for better CSS practice ***
                    deleteBtn.classList.add('delete-btn'); 
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        if (confirm(`Delete Verse ${clip.verse}?`)) {
                            deleteClip(chapterKey, clip.verse);
                        }
                    };
                    li.appendChild(deleteBtn);

                    clipsList.appendChild(li);
                });
            }
        }

        /**
         * Deletes a specific clip and re-numbers subsequent verses
         * @param {string} chapterKey - e.g., "coran_001"
         * @param {number} verseToDelete - The verse number to delete
         */
        function deleteClip(chapterKey, verseToDelete) {
            if (!db[chapterKey]) return;

            // Filter out the deleted verse
            let chapterClips = db[chapterKey];
            chapterClips = chapterClips.filter(clip => clip.verse !== verseToDelete);

            // Re-number all subsequent verses
            chapterClips.forEach((clip, index) => {
                clip.verse = index + 1;
            });

            db[chapterKey] = chapterClips;
            saveDB();
            renderCurrentChapterClips();
        }

        /**
         * Converts "HH:MM:SS.mmm" string to seconds
         * @param {string} timeString
         * @returns {number} Time in seconds
         */
        function timeStringToSeconds(timeString) {
            const parts = timeString.split(':');
            const secondsAndMs = parseFloat(parts[2]);
            return (parseInt(parts[0]) * 3600) + (parseInt(parts[1]) * 60) + secondsAndMs;
        }

        /**
         * Updates the status indicator UI
         * @param {string} state - 'orange' or 'green'
         */
        function updateTagStatusUI(state) {
            taggingState = state;
            
            // *** MODIFICATION: Use desaturated, ergonomic colors ***
            if (state === 'orange') {
                tagStatus.style.backgroundColor = '#d9822b'; // Desaturated burnt orange
                tagStatus.style.color = '#fff';
                tagStatus.textContent = 'Waiting for Arabic End (Press 1)';
            } else {
                tagStatus.style.backgroundColor = '#50a150'; // Desaturated success green
                tagStatus.style.color = '#fff';
                tagStatus.textContent = 'Waiting for Spanish End (Press 2)';
            }
        }

        /**
         * Handles the "Mark Start" action (Key '1')
         */
        function handleMarkStart() {
            if (taggingState !== 'orange') {
                console.warn("Ignored '1' press: not in correct state.");
                return; // Can only mark start from orange state
            }
            currentStartTime = audioPlayer.currentTime;
            updateTagStatusUI('green');
            console.log(`Marked START at ${formatTime(currentStartTime)}`);
        }

        /**
         * Handles the "Mark End" action (Key '2')
         */
        function handleMarkEnd() {
            if (taggingState !== 'green') {
                console.warn("Ignored '2' press: no start time marked.");
                return; // Can only mark end from green state
            }
            
            const endTime = audioPlayer.currentTime;
            if (endTime <= currentStartTime) {
                alert("End time must be after start time.");
                return;
            }

            const chapterKey = playerState.currentFile.split('.')[0];
            if (!db[chapterKey]) {
                db[chapterKey] = [];
            }
            
            const verseNum = db[chapterKey].length + 1;
            const newClip = {
                verse: verseNum,
                start: formatTime(currentStartTime),
                end: formatTime(endTime)
            };

            db[chapterKey].push(newClip);
            saveDB(); // Save and update export box
            renderCurrentChapterClips(); // Update UI list

            console.log(`Saved CLIP ${verseNum}: ${newClip.start} -> ${newClip.end}`);

            // Reset for next clip
            currentStartTime = null;
            updateTagStatusUI('orange');
        }

        /**
         * Handles global key presses for shortcuts
         * @param {KeyboardEvent} e
         */
        function handleGlobalKeydown(e) {
            // If user is typing in an input/textarea, don't trigger shortcuts
            // *** MODIFICATION: Check for any TEXTAREA or INPUT ***
            if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') {
                return;
            }

            switch (e.key) {
                case ' ':
                    e.preventDefault();
                    audioPlayer.paused ? audioPlayer.play() : audioPlayer.pause();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    audioPlayer.currentTime = Math.max(0, audioPlayer.currentTime - 1);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    audioPlayer.currentTime += 1;
                    break;
                case '1':
                    e.preventDefault();
                    handleMarkStart();
                    break;
                case '2':
                    e.preventDefault();
                    handleMarkEnd();
                    break;
            }
        }

        /**
         * Handles the click on the Import button
         */
        function handleImport() {
            const jsonToImport = importJsonText.value;
            if (!jsonToImport) {
                alert("Import box is empty.");
                return;
            }
            if (!confirm("This will OVERWRITE all locally saved data. Are you sure?")) {
                return;
            }

            try {
                const newData = JSON.parse(jsonToImport);
                db = newData; // Overwrite in-memory DB
                saveDB(); // Save to localStorage and update export box
                renderCurrentChapterClips(); // Re-render UI
                importJsonText.value = ""; // Clear import box
                alert("Import successful! All data has been overwritten.");
            } catch (e) {
                console.error("Import failed:", e);
                alert("Import failed. The JSON seems to be invalid. Check console for details.");
            }
        }

        // --- INITIALIZATION ---
        
        window.addEventListener('load', () => {
            // 1. Populate UI elements
            populateChapterSelect();

            // 2. Load data from localStorage
            loadDB();
            loadPlayerState();

            // 3. Restore state
            if (playerState.currentFile) {
                const chapterNum = playerState.currentFile.split('_')[1].split('.')[0];
                chapterSelect.value = chapterNum;
                currentChapterTitle.textContent = `coran_${chapterNum}`;
                audioPlayer.src = `Q_espanol/${playerState.currentFile}`;

                // Must wait for metadata to load before setting time
                audioPlayer.addEventListener('loadedmetadata', () => {
                    audioPlayer.currentTime = playerState.currentTime;
                    timeDisplay.textContent = formatTime(playerState.currentTime);
                }, { once: true }); // Only run this once
            
            } else {
                // Load the first chapter by default if no state
                chapterSelect.value = "001";
                loadChapter("001");
            }
            
            // 4. Render initial data
            renderCurrentChapterClips();
            updateTagStatusUI('orange');

            // 5. Attach event listeners
            document.addEventListener('keydown', handleGlobalKeydown);
            chapterSelect.addEventListener('change', (e) => loadChapter(e.target.value));
            importButton.addEventListener('click', handleImport);

            // 6. Set up continuous state saving
            audioPlayer.addEventListener('timeupdate', () => {
                const currentTime = audioPlayer.currentTime;
                timeDisplay.textContent = formatTime(currentTime);
                
                // Save state every timeupdate
                playerState.currentTime = currentTime;
                savePlayerState();
            });

            audioPlayer.addEventListener('play', () => console.log('Playback started.'));
            audioPlayer.addEventListener('pause', () => console.log('Playback paused.'));
        });

    </script>
</body>
</html>
